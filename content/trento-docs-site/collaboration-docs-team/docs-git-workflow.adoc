= Git Workflow for Trento Documentation

This document outlines the Git branching strategy for the Trento documentation project. The workflow is a **Stable Branch Model**, using two protected, long-lived branches: `main` for development and `latest` for the stable release. All changes are promoted from `main` to `latest` through a formal Pull Request process. This base model can be adjusted with an optional archiving process to preserve historical versions, making it a future-proof strategy.

== Foundation and Principles

This model is designed for:

* **Clarity:** A straightforward, two-branch system (`main` and `latest`) that is easy to understand.
* **Safety:** Protected branches and mandatory Pull Requests prevent accidental changes to production documentation.
* **Stability:** A dedicated `latest` branch provides a static, predictable URL for build teams and users.

== The Branching Model

This workflow uses two permanent branches with clearly defined roles.

`main` (The Development Branch)::
_Purpose_:: The single source of truth for all new content and future developments. All new work starts here.
_Contains_:: The `prerelease` version of the documentation.

`latest` (The Stable Branch)::
_Purpose_:: Reflects the content of the *currently* published and supported documentation.
_Contains_:: The current `released` version (e.g., v2.5).

== Branch Protection

To ensure the stability of the official documentation, the `latest` and `main` branches are **protected**. This means no one can push directly to them. Every change—whether a new release or a hotfix—**must** be proposed through a Pull Request (PR).

This rule provides two key benefits:

. **Prevents Accidents**: No one can accidentally push an incorrect or unfinished commit.
. **Enforces Review**: Every change to the official docs is reviewed by the team, improving quality and catching errors before they are published.

== The Workflow in Detail: Three Clear Use Cases

Every task falls into one of the following three processes.

=== Use Case 1: Developing New Content (Daily Work)

This is the standard process for all new documentation and ensures the `latest` branch remains stable.

. **Sync `main` and Create a Feature Branch** +
Start by ensuring your local `main` branch is up-to-date, then create a new, short-lived branch for your task.
+
[source,bash]
----
# Switch to the main branch
git checkout main
----
+
[source,bash]
----
# Pull the latest changes from the remote
git pull origin main
----
+
[source,bash]
----
# Create and switch to a new branch for your task
git checkout -b feature/describe-new-api
----

. **Do the Work** +
Make all your changes and commits on your `feature/describe-new-api` branch.

. **Integrate via Pull Request** +
When the work is complete, push your branch and open a Pull Request on GitHub, targeting the `main` branch for review and merging.

[IMPORTANT]
====
New content is *always* and *only* integrated into the `main` branch.
====

=== Use Case 2: Publishing a New Release

This is the formal process for promoting `prerelease` content from `main` to become the new official version on `latest`.

. **Create a Release Preparation Branch** +
This branch is a temporary staging area to prepare the release.
+
[CAUTION]
Don't forget to pull the latest state of main before a release
+
+
[source,bash]
----
# Switch to the latest branch
git checkout latest
----
+
[source,bash]
----
# Ensure it is synchronized with the remote
git pull origin latest
----
+
[source,bash]
----
# Create a release preparation branch from it
git checkout -b release/prepare-v2.6
----
. **Merge `main` and Resolve Conflicts** +
Pull in all the new documentation from `main`.
+
[source,bash]
----
# Merge the main branch into your release preparation branch
git merge main
----
+
[CAUTION]
This merge will likely cause a predictable conflict in the `antora.yml` file. This is expected. Resolve the conflict by keeping the structure from the `latest` branch's version, and then commit the merge.
+
[source,bash]
----
# Manually edit antora.yml to fix conflict markers, then stage the file
git add antora.yml
----
+
[source,bash]
----
# Commit the merge
git commit
----
. **Update the Version Number** +
Make a final commit on the `release/prepare-v2.6` branch to update the version number in `antora.yml` to reflect the new release (e.g., change `2.5` to `2.6`).

. **Create and Merge the Release Pull Request** +
Push the release branch and open a Pull Request targeting `latest`.
+
[source,bash]
----
# Push the release preparation branch to the remote
git push origin release/prepare-v2.6
----
+
After the team reviews and approves the PR, merge it. The `latest` branch is now officially updated to v2.6.

[IMPORTANT]
====
Content flows from `main` into `latest` via a reviewed Pull Request.
====

. **Rebuild the Antora Page by using GitHub Actions workflow** +
Trigger manually the rebuild or wait for the weekly automated build process to see the changes at link::https://www.trento-project.io/docs/[www.trento-project.io/docs]

=== Use Case 3: Applying a Critical Hotfix

This process is for urgent corrections to published documentation.

. **Create the Fix in `main` (The Golden Rule)** +
The fix is **always** created and merged into the `main` branch first. This prevents the bug from reappearing in future releases.
.. Create a `fix/*` branch from `main`.
.. Make the correction and commit it. The commit should be small and contain only the fix.
.. Merge the `fix/*` branch back into `main` via a Pull Request.

. **Apply the Fix to `latest` via PR** +
After the fix is in `main`, port the specific commit over.
.. **Find the Commit Hash** +
In the `main` branch's history, find and copy the hash of the commit that contains the fix.
.. **Create a Hotfix Branch and Cherry-Pick**
+
[source,bash]
----
# Switch to the branch you need to patch
git checkout latest
----
+
[source,bash]
----
# Ensure it's up-to-date
git pull origin latest
----
+
[source,bash]
----
# Create a hotfix branch from it
git checkout -b hotfix/backport-urgent-typo
----
+
[source,bash]
----
# Apply the specific commit from main
git cherry-pick <paste-commit-hash-of-the-fix-here>
----
.. **Create and Merge the Hotfix Pull Request** +
Push the hotfix branch and create a PR targeting `latest`.
+
[source,bash]
----
# Push the branch and create a PR
git push origin hotfix/backport-urgent-typo
----

[IMPORTANT]
====
A hotfix is always implemented in `main` first and then ported via `cherry-pick` and a Pull Request.
====

== Optional: Archiving Old Versions

When the project matures and there is a need to keep historical versions of the documentation available,enhance the release process by adding an "archiving" step.
This process is performed at the beginning of **Use Case 2: Publishing a New Release**.

. **Before creating the `release/prepare-v*` branch, archive the current `latest` branch:**
+
[source,bash]
----
# Switch to the latest branch
git checkout latest
----
+
[source,bash]
----
# Ensure it's synchronized
git pull origin latest
----
+
[source,bash]
----
# Create a new, permanent branch named after the version it contains (e.g., v2.5)
git checkout -b v2.5
----
+
[source,bash]
----
# Push the new archive branch to the remote
git push origin v2.5
----

. **Update Your Antora Playbook** +
After archiving, you must update your `antora-playbook.yml` to add the new `v2.5` branch to the list of content sources on main. This will make the old version selectable in your documentation site's UI.