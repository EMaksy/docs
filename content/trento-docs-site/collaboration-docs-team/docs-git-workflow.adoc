= Git Workflow for Trento Documentation

== The Two-Branch Model

This workflow is designed for simplicity and safety, using only two permanent branches with clearly defined roles.

`main` (The Development Branch)::
* *Purpose:* The single source of truth for all new content and future developments. All new work starts here.
* *Corresponds to:* The `prerelease` version of the documentation.

`latest` (The Stable Branch)::
* *Purpose:* This branch reflects the content of the officially published and supported documentation. It is only updated for new releases or critical hotfixes.
* *Corresponds to:* The current `released` version.

== Branch Protection

To ensure the stability of the official documentation, the `latest` branch and `main` is **protected**. This means no one can push directly to it. Every change—whether a major release or a minor hotfix—**must** be proposed through a Pull Request (PR).

This rule adds two key benefits:

. *Prevents Accidents:* No one can accidentally push an incorrect or unfinished commit.
. *Enforces Review:* Every change to the official docs is reviewed by the team, improving quality and catching errors before they are published.

== The Workflow in Detail: Three Clear Use Cases

Every task falls into one of the following three processes, which are designed to work with branch protection.

=== Use Case 1: Developing New Content

This is the standard process for all daily work. It ensures that the `latest` branch remains stable and untouched.

. *Create a Branch:* Every new task (e.g., a new chapter, a feature description, or a correction) begins on a new, short-lived branch created from `main`.
+
[source,bash]
----
# Ensure your local main is up-to-date
git checkout main
git pull origin main

# Create a new branch for your task
git checkout -b feature/new-content
----

. *Do the Work:* Make all your changes and commits on this new branch.

. *Integrate:* When the work is complete, merge the branch back into `main` using a Pull Request (PR).

====
New content is *always* and *only* integrated into the `main` branch.
====

=== Use Case 2: Publishing a New Release

This is a deliberate, formal process to promote `prerelease` content to become the new official version.

. *Create a Release Preparation Branch:* Start by creating a new branch from the `latest` branch. This branch will be used to stage all the changes for the new release.
+
[source,bash]
----
# Ensure your local latest branch is up-to-date
git checkout latest
git pull origin latest

# Create a new branch for the release
git checkout -b release/prepare-v*
----

. *Merge `main` and Resolve Conflicts:* On your new `release/*` branch, merge `main`. This will pull in all the new documentation.
+
[source,bash]
----
git merge main
----
+
IMPORTANT: This merge will cause a predictable conflict in the `antora.yml` file. This is expected. Resolve it by keeping the content from the `latest` side of the conflict, then commit the merge.
+
[source,bash]
----
# Manually edit antora.yml to fix the conflict markers
git add antora.yml
git commit
----

. *Update the Version:* On the same branch, make a final commit to update the version number in `antora.yml` (e.g., update `2.5` to `2.6`).

. *Create a Pull Request:* Push your `release/prepare-v2.6` branch and open a Pull Request on GitHub targeting the `latest` branch.

. *Review and Merge:* The team reviews the PR, which contains a complete summary of the new release. After approval, the PR is merged, and the `latest` branch is officially updated.

====
Content flows from `main` into `latest` via a reviewed Pull Request.
====

=== Use Case 3: Applying a Critical Hotfix

This process is for urgent corrections to the already published documentation. It uses `cherry-pick` in a controlled and safe manner.

. *Create the Fix in `main` (The Golden Rule):* The fix is *always* created and merged into the `main` branch first. This prevents future conflicts.
.. Create a `fix/*` branch from `main`.
.. Make the correction and commit it. The commit should be small and contain only the fix.
.. Merge the `fix/*` branch back into `main` via a Pull Request.

. *Apply the Fix to `latest` via Pull Request:* After the fix is in `main`, port the specific commit over to the `latest` branch using a PR.
+
[source,bash]
----
# Switch to the latest branch and ensure it's up-to-date
git checkout latest
git pull origin latest

# Create a hotfix branch from latest
git checkout -b hotfix/backport-urgent-typo

# Apply the specific commit from main
# Find the <commit-hash> from the git history of the main branch
git cherry-pick <commit-hash-of-the-fix>

# Push the branch and create a PR against 'latest'
git push origin hotfix/backport-urgent-typo
----

====
A hotfix is always implemented in `main` and then ported to `latest` via `cherry-pick` and a Pull Request.
====

== A Note on `git cherry-pick`

It is critical to understand how `cherry-pick` works to use it safely.

What it does::
`cherry-pick` copies the changes from a commit and creates a *brand new commit* on the target branch. The original and the copied commit have different IDs, even though they contain the same content change.

The risk::
If changes are copied back and forth without a clear process, Git can "forget" the relationship between the changes. This can create "time bombs" that lead to unexpected and difficult merge conflicts later.

Why our workflow is safe::
By following the strict rule of **"Fix always in `main` first, then port to `latest`"**, we defuse this risk. When you perform the next major release merge, Git is smart enough to see that the content change from the hotfix already exists in both histories and won't try to apply it again.

== Workflow Summary

[options="header"]
|===
| Action | How the Process Starts | Target Branch | Method
| *New Content* | Branch from `main` | `main` | Merge via Pull Request
| *New Release* | Branch from `latest` to create a release branch | `latest` | On the release branch, merge content from `main`. Then merge the release branch into `latest` via Pull Request.
| *Hotfix* | Branch from `latest` to create a hotfix branch | `latest` | On the hotfix branch, `cherry-pick` a commit from `main`. Then merge the hotfix branch into `latest` via Pull Request.
|===
